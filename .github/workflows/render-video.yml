name: Render Video

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: 'Project ID to render'
        required: true
        type: string
      composition_data:
        description: 'Composition data as JSON (optional for auto-trigger)'
        required: false
        type: string
  repository_dispatch:
    types: [render-video]

jobs:
  render:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Install Remotion CLI
      run: npm install -g @remotion/cli
      
    - name: Setup system for rendering
      run: |
        # Increase memory limits
        echo "Setting up system for stable rendering..."
        # Clear any existing Chrome processes
        pkill -f chrome || true
        pkill -f chromium || true
        # Set environment variables for better stability
        export NODE_OPTIONS="--max-old-space-size=4096"
        echo "System ready for rendering"
      
    - name: Create render script
      run: |
        cat > render-video.js << 'EOF'
        const { bundle } = require('@remotion/bundler');
        const { getCompositions, renderMedia } = require('@remotion/renderer');
        const path = require('path');
        const fs = require('fs');
        
        async function renderVideo() {
          try {
            const projectId = process.env.PROJECT_ID;
            let compositionData = null;
            
            console.log('=== RENDER SCRIPT DEBUG ===');
            console.log('Project ID:', projectId);
            console.log('Composition data env var exists:', !!process.env.COMPOSITION_DATA);
            console.log('Composition data env var value:', process.env.COMPOSITION_DATA);
            
            // Try to parse composition data if provided
            if (process.env.COMPOSITION_DATA && process.env.COMPOSITION_DATA !== 'auto-triggered') {
              try {
                const parsedData = JSON.parse(process.env.COMPOSITION_DATA);
                console.log('ðŸ” Parsed data keys:', Object.keys(parsedData));
                console.log('ðŸ” Has inputs:', !!parsedData.inputs);
                console.log('ðŸ” Has composition_data in inputs:', !!parsedData.inputs?.composition_data);
                
                // Check if the data is nested (has inputs.composition_data)
                if (parsedData.inputs && parsedData.inputs.composition_data) {
                  // Parse the nested composition_data string
                  compositionData = JSON.parse(parsedData.inputs.composition_data);
                  console.log('âœ… Successfully parsed nested composition data');
                } else {
                  // Direct composition data
                  compositionData = parsedData;
                  console.log('âœ… Successfully parsed direct composition data');
                }
                
                console.log('Project:', compositionData.project?.title);
                console.log('Tracks:', compositionData.tracks?.length);
                console.log('Media items:', Object.keys(compositionData.mediaItems || {}).length);
                console.log('Full composition data:', JSON.stringify(compositionData, null, 2));
              } catch (e) {
                console.log('âŒ Could not parse composition data:', e.message);
                console.log('Raw composition data:', process.env.COMPOSITION_DATA);
                console.log('Will use sample data');
              }
            }
            
            // If no composition data, create a sample for testing
            if (!compositionData) {
              console.log('Using sample composition data for project:', projectId);
              compositionData = {
                project: {
                  id: projectId,
                  title: `Project ${projectId}`,
                  createdAt: Date.now()
                },
                tracks: [
                  {
                    id: 'sample-track',
                    type: 'video',
                    projectId: projectId
                  }
                ],
                frames: {
                  'sample-track': [
                    {
                      id: 'sample-frame',
                      trackId: 'sample-track',
                      timestamp: 0,
                      duration: 5000,
                      data: { mediaId: 'sample-media' }
                    }
                  ]
                },
                mediaItems: {
                  'sample-media': {
                    id: 'sample-media',
                    mediaType: 'video',
                    url: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4'
                  }
                }
              };
            }
            
            console.log('Starting video render for project:', projectId);
            console.log('Tracks:', compositionData.tracks?.length || 'undefined');
            console.log('Media items:', Object.keys(compositionData.mediaItems || {}).length);
            
            // Bundle the video composition
            const bundled = await bundle({
              entryPoint: path.join(process.cwd(), 'src/remotion-entry.js'),
              webpackOverride: (config) => {
                // Add path aliases to resolve @/ imports
                config.resolve.alias = {
                  ...config.resolve.alias,
                  '@': path.resolve(process.cwd(), 'src'),
                };
                return config;
              },
              ignoreRegisterRootWarning: true,
            });
            
            // Get the composition
            const compositions = await getCompositions(bundled);
            console.log('Available compositions:', compositions.map(c => c.id));
            
            // Use the test-composition
            const compositionToRender = compositions.find((c) => c.id === 'test-composition');
            
            console.log('Found composition:', compositionToRender ? compositionToRender.id : 'NOT FOUND');
            console.log('Composition duration:', compositionToRender ? compositionToRender.durationInFrames : 'N/A');
            console.log('Composition width:', compositionToRender ? compositionToRender.width : 'N/A');
            console.log('Composition height:', compositionToRender ? compositionToRender.height : 'N/A');
            console.log('Composition component:', compositionToRender ? typeof compositionToRender.component : 'N/A');
            
            if (!compositionToRender) {
              throw new Error('Composition "test-composition" not found');
            }
            
            // Calculate duration based on frames
            let maxTimestamp = 0;
            for (const trackFrames of Object.values(compositionData.frames)) {
              for (const frame of trackFrames) {
                maxTimestamp = Math.max(maxTimestamp, frame.timestamp + frame.duration);
              }
            }
            const durationInSeconds = Math.max(5, Math.ceil(maxTimestamp / 1000));
            
            // Render the video
            const outputPath = path.join(process.cwd(), 'rendered-video.mp4');
            
            console.log('=== RENDERING VIDEO ===');
            console.log('Composition to render:', compositionToRender.id);
            console.log('Input props being passed:', JSON.stringify({ compositionData }, null, 2));
            console.log('Rendering video...');
            await renderMedia({
              composition: compositionToRender,
              serveUrl: bundled,
              codec: 'h264',
              outputLocation: outputPath,
              inputProps: {
                compositionData: compositionData,
              },
              // Add stability configurations to prevent browser crashes
              browserExecutable: undefined, // Use system Chrome
              chromiumOptions: {
                args: [
                  '--no-sandbox',
                  '--disable-setuid-sandbox',
                  '--disable-dev-shm-usage',
                  '--disable-accelerated-2d-canvas',
                  '--no-first-run',
                  '--no-zygote',
                  '--disable-gpu',
                  '--single-process',
                  '--disable-extensions',
                  '--disable-background-timer-throttling',
                  '--disable-backgrounding-occluded-windows',
                  '--disable-renderer-backgrounding',
                  '--disable-features=TranslateUI',
                  '--disable-ipc-flooding-protection',
                  '--memory-pressure-off',
                  '--max_old_space_size=4096'
                ]
              },
              timeoutInMilliseconds: 300000, // 5 minutes timeout
            });
            
            console.log('Video rendered successfully:', outputPath);
            
            // Upload as artifact
            if (fs.existsSync(outputPath)) {
              console.log('Video file exists, size:', fs.statSync(outputPath).size);
            }
            
          } catch (error) {
            console.error('Error rendering video:', error);
            process.exit(1);
          }
        }
        
        renderVideo();
        EOF
        
    - name: Render video
      env:
        PROJECT_ID: ${{ github.event.inputs.project_id || github.event.client_payload.project_id }}
        COMPOSITION_DATA: ${{ github.event.inputs.composition_data || github.event.client_payload.composition_data || 'auto-triggered' }}
        NODE_OPTIONS: "--max-old-space-size=4096"
      run: node render-video.js
      
    - name: Upload video artifact
      uses: actions/upload-artifact@v4
      with:
        name: rendered-video
        path: rendered-video.mp4
        retention-days: 7
        
    - name: Create download URL
      run: |
        echo "Video rendered successfully!"
        echo "Download the video from the Actions tab in this repository."
        echo "The video will be available as an artifact for 7 days." 